---
title: Web 拡張機能のイベントタイプ
description: Adobe Experience Platform の Web 拡張機能のイベントタイプライブラリモジュールを定義する方法について説明します。
source-git-commit: 7e27735697882065566ebdeccc36998ec368e404
workflow-type: tm+mt
source-wordcount: '1048'
ht-degree: 71%

---

# イベントタイプ web拡張機能用

>[!NOTE]
>
>Adobe Experience Platform Launchは、Adobe Experience Platformのデータ収集テクノロジーのスイートとしてリブランドされました。 その結果、製品ドキュメント全体でいくつかの用語の変更がロールアウトされました。用語の変更点の一覧については、次の[ドキュメント](../../term-updates.md)を参照してください。

タグルールでは、イベントとは、ルールを起動するために発生する必要があるアクティビティです。 例えば、Web拡張機能は、特定のマウスまたはタッチジェスチャーが発生するのを監視する「ジェスチャー」イベントタイプを提供できます。 このジェスチャーが発生すると、イベントロジックによってルールが実行されます。

イベントタイプライブラリモジュールは、アクティビティが発生したときにそれを検出し、関数を呼び出して関連ルールを実行するように設計されています。検出されるイベントはカスタマイズ可能です。例えば、は、ユーザーが特定のジェスチャーを行ったか、高速スクロールしたか、何かとやり取りしたかを検出できます。

このドキュメントでは、Adobe Experience PlatformでWeb拡張機能のイベントタイプを定義する方法について説明します。

>[!NOTE]
>
>このドキュメントは、ライブラリモジュールと、それらがweb拡張機能に統合される方法についての知識があることを前提としています。 このガイドに戻る前に、[ライブラリモジュールの形式](./format.md)の概要を参照して、実装に関する基礎知識を確認してください。

イベントタイプは拡張機能によって定義され、通常は次の要素で構成されます。

1. データ収集UI内に表示される[ビュー](./views.md)で、イベントの設定を変更できます。
2. タグランタイムライブラリ内で生成され、設定を解釈し、特定のアクティビティが発生するのを監視するライブラリモジュール。

`module.exports` は、`settings` と `trigger` の両方のパラメーターを受け入れます。これにより、イベントタイプをカスタマイズできます。

```js
module.exports = function(settings, trigger) { … };
```

| パラメーター | 説明 |
| --- | --- |
| `settings` | イベントタイプの表示でユーザーが設定した設定を含むオブジェクト。このオブジェクトに何を取り込むかは、完全に制御できます。 |
| `trigger` | ルールを起動するたびにモジュールが呼び出す必要がある関数。`settings` オブジェクト、`trigger` 関数、ルールの間には一対一の関係があります。つまり、あるルールに対して受け取ったトリガー関数を使用して、別のルールを実行することはできません。 |

>[!NOTE]
>
>エクスポートされた関数は、イベントタイプを使用するように設定された各ルールのために 1 回呼び出されます。

例として、5 秒経過のアクティビティを使用すると、5 秒経過した後にアクティビティが発生し、ルールが起動します。モジュールはこの例のようになります。

```js
module.exports = function(settings, trigger) {
  setTimeout(trigger, 5000);
};
```

Adobe Experience Platform ユーザーがデュレーションを設定できるようにする場合は、設定オブジェクトにデュレーションを入力して保存するオプションが必要です。オブジェクトは次のようになります。

```js
{
  "duration": 25000
}
```

ユーザー定義のデュレーションで動作させるには、モジュールを更新してこれを含める必要があります。

```js
module.exports = function(settings, trigger) {
  setTimeout(trigger, settings.duration);
};
```

## コンテキストイベントデータを渡す

ルールがトリガーされるときに、発生したイベントに関する追加の詳細を提供すると便利なことがよくあります。ルールを作成するユーザーにとっては、特定の動作を完了するときに、この情報が役立つ場合があります。例えば、マーケターが、ユーザーが画面をスワイプするたびに Analytics ビーコンが送信されるルールを作成するとします。マーケターがこのイベントタイプを使用して適切なルールをトリガーできるように、拡張機能では `swipe` イベントタイプを指定する必要があります。スワイプが発生した角度をマーケターがビーコンに含めようとしても、追加情報を提供しなければこれを実現するのは困難です。発生したイベントに関する追加情報を提供するには、`trigger` 関数を呼び出すときにオブジェクトを渡します。 次に例を示します。

```js
trigger({
  swipeAngle: 90 // the value would be the detected angle
});
```

その後、マーケターは、テキストフィールドに値 `%event.swipeAngle%` を指定することで、Analytics ビーコンでこの値を使用できます。 また、他のコンテキスト（カスタムコードアクションなど）内からも `event.swipeAngle` にアクセスできます。同様に、マーケターに役立つ他のタイプのオプションイベント情報を含めることができます。

### [!DNL nativeEvent]

イベントタイプがネイティブイベントに基づいている場合（例えば、拡張機能で `click` イベントタイプが指定された場合）、`nativeEvent` プロパティを次のように設定することをお勧めします。

```js
trigger({
  nativeEvent: nativeEvent // the value would be the underlying native event
});
```

これは、マーケターがカーソル座標などのネイティブイベントから任意の情報にアクセスしようとする場合に役立ちます。

### [!DNL element]

要素と発生したイベントとの間に強い関係がある場合は、`element` プロパティを要素の DOM ノードに設定することをお勧めします。例えば、拡張機能が `click` イベントタイプを指定しており、ID が `herobanner` の要素を選択した場合にのみルールが起動するよう、マーケターがイベントタイプを設定できるとします。この場合、ユーザーがヒーローバナーを選択した場合は、`trigger` を呼び出し、`element` をヒーローバナーの DOM ノードに設定することをお勧めします。

```js
trigger({
  element: element // the value would be the DOM node
});
```

## ルールの順序を順守する

タグを使用すると、ユーザーはルールを並べ替えることができます。 例えば、ユーザーは、方向変更イベントタイプを使用し、ルールが実行される順序をカスタマイズする 2 つのルールを作成できます。Adobe Experience Platformユーザーが、ルールAの方向変更イベントに対して順序値`2`を指定し、ルールBの方向変更イベントに対して順序値`1`を指定したとします。これは、モバイルデバイスで向きが変更された場合、ルールAの前にルールBを実行する必要があることを示します（下位の値を持つルールが最初に実行されます）。

前述したように、イベントモジュールで書き出された関数は、イベントタイプを使用するように設定された各ルールに対して 1 回だけ呼び出されます。 書き出された関数が呼び出されるたびに、特定のルールに結び付けられた一意の `trigger` 関数が渡されます。 前述のシナリオでは、エクスポートされた関数は、ルールBに結び付けられた`trigger`関数で1回呼び出され、次に、ルールAに結び付けられた`trigger`関数で再び呼び出されます。ルールBは、ユーザーがルールAよりも低い順序の値を指定したために最初になります。ライブラリモジュールで方向の変更が検出された場合、ライブラリモジュールに提供されたのと同じ順序で`trigger`関数を呼び出すことが重要です。

次のコード例では、方向変更が検出された場合、トリガー関数は、書き出された関数に指定されたのと同じ順序で呼び出されることに注意してください。

```js
var triggers = [];

window.addEventListener('orientationchange', function() {
  triggers.forEach(function(trigger) {
    trigger();
  });
});

module.exports = function(settings, trigger) {
  triggers.push(trigger);
};
```

これにより、ユーザー指定の順序が維持されます。

不適切な実装では、次のように、トリガー関数が異なる順序で呼び出されます。

```js
var triggers = [];

window.addEventListener('orientationchange', function() {
  for (var i = triggers.length - 1; i >= 0; i--) {
    triggers[i]();
  }
});

module.exports = function(settings, trigger) {
  triggers.push(trigger);
};
```

自然なプログラミングの慣行では、通常、適切な順序を維持しますが、その影響を認識し、それに応じて開発することが重要です。
