---
title: Web 拡張機能のイベントタイプ
description: Adobe Experience Platform の Web 拡張機能のイベントタイプライブラリモジュールを定義する方法について説明します。
exl-id: dbdd1c88-5c54-46be-9824-2f15cce3d160
source-git-commit: 8ded2aed32dffa4f0923fedac7baf798e68a9ec9
workflow-type: tm+mt
source-wordcount: '1052'
ht-degree: 98%

---

# イベントタイプ （web 拡張機能）

>[!NOTE]
>
>Adobe Experience Platform Launch は、Adobe Experience Platform のデータ収集テクノロジースイートとしてリブランドされています。 その結果、製品ドキュメント全体でいくつかの用語の変更がロールアウトされました。 用語の変更点の一覧については、次の[ドキュメント](../../term-updates.md)を参照してください。

タグのルールにおいて、イベントとは、ルールを起動するために発生する必要があるアクティビティです。 たとえば、マウスまたはタッチの特定のジェスチャーが発生するのを監視する「ジェスチャー」イベントタイプを web 拡張機能で提供する場合があります。このジェスチャーが発生すると、イベントロジックによってルールが実行されます。

イベントタイプライブラリモジュールは、アクティビティが発生したタイミングを検出し、関数を呼び出して関連ルールを実行するように設計されています。検出されるイベントはカスタマイズ可能です。たとえば、ユーザーが特定のジェスチャーをおこなったり、すばやくスクロールしたり、何かを操作したりしたことを検出できます。

このドキュメントでは、Adobe Experience Platform で web 拡張機能のイベントタイプを定義する方法について説明します。

>[!NOTE]
>
>このドキュメントでは、読者がライブラリモジュールと、ライブラリモジュールがタグ拡張機能に統合される仕組みについて理解していることを前提としています。このガイドに戻る前に、 [ライブラリモジュールの形式](./format.md) の概要を参照して、実装に関する基礎知識を確認してください。

イベントタイプは拡張機能で定義され、通常は次の要素で構成されます。

1. A [表示](./views.md) イベントの設定を変更できるExperience PlatformUI およびデータ収集 UI 内に表示されます。
2. タグのランタイムライブラリ内で生成されるライブラリモジュール。設定を解釈し、特定のアクティビティが発生するのを監視します。

`module.exports` は、`settings` と `trigger` の両方のパラメーターを受け入れます。これにより、イベントタイプをカスタマイズできます。

```js
module.exports = function(settings, trigger) { … };
```

| パラメーター | 説明 |
| --- | --- |
| `settings` | イベントタイプの表示でユーザーが設定した設定を含むオブジェクト。このオブジェクトに何を取り込むかは、完全に制御できます。 |
| `trigger` | ルールを起動するたびにモジュールが呼び出す必要がある関数。`settings` オブジェクト、`trigger` 関数、ルールの間には一対一の関係があります。つまり、あるルールに対して受け取ったトリガー機能を使用して、別のルールを実行することはできません。 |

>[!NOTE]
>
>エクスポートされた関数は、イベントタイプを使用するように設定された各ルールのために 1 回呼び出されます。

例として、5 秒を経過したアクティビティを使用すると、5 秒が経過した後にアクティビティが発生し、ルールが起動します。モジュールは次の例のようになります。

```js
module.exports = function(settings, trigger) {
  setTimeout(trigger, 5000);
};
```

Adobe Experience Platform ユーザーがデュレーションを設定できるようにする場合は、settings オブジェクトにデュレーションを入力して保存するオプションが必要です。オブジェクトは次のようになります。

```js
{
  "duration": 25000
}
```

ユーザー定義のデュレーションを操作するには、モジュールを更新してこれを含める必要があります。

```js
module.exports = function(settings, trigger) {
  setTimeout(trigger, settings.duration);
};
```

## コンテキストイベントデータの受け渡し

ルールがトリガーされる場合、多くの場合、発生したイベントに関する追加の詳細を提供すると便利です。ルールを作成するユーザーにとっては、特定の動作を完了するときに、この情報が役立つ場合があります。例えば、マーケターが、ユーザーが画面をスワイプするたびに Analytics ビーコンが送信されるルールを作成したい場合、マーケターがこのイベントタイプを使用して適切なルールをトリガーできるように、拡張機能では `swipe` イベントタイプを指定する必要があります。マーケターが、ビーコンでスワイプが発生した角度を含めようとした場合、追加情報を提供しなければこれを実現するのは困難です。発生したイベントに関する追加情報を提供するには、`trigger` 関数を呼び出すときにオブジェクトを渡します。 次に例を示します。

```js
trigger({
  swipeAngle: 90 // the value would be the detected angle
});
```

その後、マーケターは、テキストフィールドに値 `%event.swipeAngle%` を指定することで、Analytics ビーコンでこの値を使用できます。 また、他のコンテキスト（カスタムコードアクションなど）内からも `event.swipeAngle` にアクセスできます。他のタイプのオプションのイベント情報を含めることもできます。この情報はマーケターにとっても役立ちます。

### [!DNL nativeEvent]

イベントタイプがネイティブイベントに基づいている場合（例えば、拡張機能で `click` イベントタイプが指定された場合）、`nativeEvent` プロパティを次のように設定することをお勧めします。

```js
trigger({
  nativeEvent: nativeEvent // the value would be the underlying native event
});
```

これは、マーケターがカーソル座標などのネイティブイベントから任意の情報にアクセスしようとする場合に役立ちます。

### [!DNL element]

要素と発生したイベントとの間に強力な関係がある場合は、`element` プロパティを要素の DOM ノードに設定することをお勧めします。例えば、拡張機能で `click` イベントタイプを指定し、ID が `herobanner` の要素を選択した場合にのみルールが起動するようにマーケターがイベントタイプを設定できる場合などです。この場合、ユーザーがヒーローバナーを選択した場合は、`trigger` を呼び出し、`element` をヒーローバナーの DOM ノードに設定することをお勧めします。

```js
trigger({
  element: element // the value would be the DOM node
});
```

## ルールの順序を順守する

タグを使用すると、ルールを並べ替えることができます。例えば、ユーザーは、方向変更イベントタイプを使用し、ルールが実行される順序をカスタマイズする 2 つのルールを作成できます。Adobe Experience Platform のユーザーが、ルール A の方向変更イベントに順序値 `2`、ルール B の方向変更イベントに順序値 `1` を指定したとします。この場合、モバイルデバイスの向きが変わると、ルール A の前にルール B を実行する必要があることを示します（順序値が小さいルールが最初に実行されます）。

前述したように、イベントモジュールで書き出された関数は、イベントタイプを使用するように設定された各ルールに対して 1 回だけ呼び出されます。 書き出された関数が呼び出されるたびに、特定のルールに結び付けられた一意の `trigger` 関数が渡されます。 前述のシナリオでは、書き出された関数は、ルール B に結び付けられた `trigger` 関数で一度呼び出されてから、ルール A に結び付けられた `trigger` 関数で再び呼び出されます。ルール B が最初に実行されるのは、ルール B の順序値はルール A よりも小さいためです。ライブラリモジュールが方向変更を検出したときに、ライブラリモジュールに提供されたのと同じ順序で `trigger` 関数を呼び出すことが重要です。

次のコード例では、方向変更が検出された場合、トリガー関数は、書き出された関数に指定されたのと同じ順序で呼び出されることに注意してください。

```js
var triggers = [];

window.addEventListener('orientationchange', function() {
  triggers.forEach(function(trigger) {
    trigger();
  });
});

module.exports = function(settings, trigger) {
  triggers.push(trigger);
};
```

これにより、ユーザー指定の順序が維持されます。

不適切な実装では、次のように、トリガー関数が異なる順序で呼び出されます。

```js
var triggers = [];

window.addEventListener('orientationchange', function() {
  for (var i = triggers.length - 1; i >= 0; i--) {
    triggers[i]();
  }
});

module.exports = function(settings, trigger) {
  triggers.push(trigger);
};
```

自然なプログラミングの慣行では、通常、適切な順序を維持しますが、その影響を認識し、それに応じて開発することが重要です。
