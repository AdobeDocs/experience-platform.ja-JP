---
keywords: Experience Platform；ホーム；人気のトピック；モデルベースのスキーマ；リレーショナルスキーマ；リレーショナルスキーマ；スキーマ；スキーマ；xdm；エクスペリエンスデータモデル；
solution: Experience Platform
title: モデルベースのスキーマ
description: 機能、必須フィールド、関係、制限など、Adobe Experience Platformのモデルベースのスキーマ（リレーショナルスキーマとも呼ばれます）について説明します。
badge: 限定提供
source-git-commit: 192e97c97ffcb2d695bcfa6269cc6920f5440832
workflow-type: tm+mt
source-wordcount: '1306'
ht-degree: 0%

---

# モデルベースのスキーマ

>[!AVAILABILITY]
>
>Data Mirrorおよびモデルベースのスキーマは、Adobe Journey Optimizer **オーケストレートキャンペーン** のライセンスホルダーが使用できます。 ライセンスとイネーブルメント機能に応じて、Customer Journey Analytics ユーザー向けの **限定リリース** としても使用できます。 アクセスについては、Adobe担当者にお問い合わせください。

モデルベースのスキーマは、Adobe Experience Platform データレイク内の構造化データを表現するための、柔軟で制御されたモデリングパターンを提供します。 統合スキーマや完全なリレーショナルデータベースシステムに依存することなく、強制的なプライマリキー、スキーマレベルの関係、レコードの詳細な制御をサポートします。

>[!IMPORTANT]
>
>データ削除に関する考慮事項は、すべてのモデルベースのスキーマ実装に適用されます。 これらのスキーマを使用するアプリケーションでは、削除が関連データセット、コンプライアンス要件およびダウンストリームプロセスに与える影響を理解する必要があります。 実装する前に、削除シナリオを計画し、[ データハイジーンのガイダンス ](../../hygiene/ui/record-delete.md#model-based-record-delete) を確認してください。

>[!NOTE]
>
>アプリケーションは、リレーショナルデータモデリングのユースケースのスキーマ作成をリクエストする際に、モデルベースのスキーマを「リレーショナルスキーマ」と呼ぶ場合があります。

モデルベースのスキーマを使用して、次の操作を行います。

* 単一フィールドまたは複合プライマリキーを適用してデータの整合性を確保する。
* 挿入、更新、削除のバージョン管理を使用して、正確な変更トラッキングを有効にします。
* 再利用可能なスキーマレベルの関係を定義して、実際のエンティティ接続をモデル化します。
* 複数のデータモデルをサポートすることで、アプリケーション間でスキーマ構造を複製するのを避けます。
* 結合スキーマの制約を回避して、オンボーディングを合理化し、スキーマの膨張を減らし、不要なスキーマ変更を回避します。

## モデルベースのスキーマと標準の XDM スキーマの違い

Experience Platformの標準 XDM スキーマは、レコード、時系列またはアドホックの 3 つのデータ動作のいずれかに従います。 定義と詳細については、[XDM データの動作 ](https://experienceleague.adobe.com/ja/docs/experience-platform/xdm/home#data-behaviors) を参照してください。

従来のモデルでは、レコードと時系列スキーマは [ 和集合スキーマ ](../api/unions.md) に参加します（[ 和集合スキーマ UI ガイド ](../../profile/ui/union-schema.md) も参照）。 これらのスキーマは、共有 [ フィールドグループ ](./composition.md#field-group) が更新されると自動的に進化します。また、カスタムフィールドはテナント名前空間の下にネストする必要があります。 このモデルは強力ですが、オンボーディングの速度が低下したり、未使用のフィールドを含む過度に複雑なスキーマが生成されたり、追加のデータマッピングや変換が必要になったりする可能性があります。 これらの要因により、学習曲線が増加し、継続的なメンテナンス作業が増えます。

モデルベースのスキーマは、結合スキーマの依存関係を削除します。これにより、共有フィールドグループからの自動更新が排除され、テナント名前空間の制限なしで直接フィールドを定義できるようになります。 プライマリキー、関係、初期スキーマデザインを明示的に制御できるので、作成時にニーズに合わせてデータを簡単にモデル化できます。

## モデルベースのスキーマの機能

ガバナンス、整合性、相互運用性を維持しながら、データレイク内の構造化データをモデル化するには、次の機能を使用します。

* **スキーマ動作のサポート**：次を使用してを設定します。
   * **動作を記録**：顧客、アカウント、キャンペーンなど、エンティティの現在の状態をキャプチャします。
   * **時系列の動作**：イベントとイベントが発生する時間を取得します。シーケンスや時間の経過に伴う変化を追跡するのに役立ちます。
* **プライマリキーの適用**：各レコードを一意に識別し、取り込み中の重複を防ぐためのプライマリキーを定義します。
* **バージョン管理**: **バージョン識別子** （記述子）を使用して、レコードが順不同で到着した場合でも、更新が正しい順序で適用されるようにします。
* **関係マッピング**：モデルベースのスキーマ間、またはモデルベースのスキーマと標準のスキーマの間に、1 対 1 または多対 1 の関係を作成します。 関係定義は、効率的な結合を可能にするために記述子として保存されます。
* **進化のシンプル化**：モデルベースのスキーマは、和集合ビューに関与せず、共有フィールドグループが変更された場合は更新されず、予期しないダウンストリームの変更を防ぎます。
* **柔軟なフィールド定義**：テナント ID の名前空間を設定せずに直接フィールドを追加します。 モデルベースのスキーマは、XDM フィールドグループをサポートしません。
* **結合スキーマへの依存なし**：クエリのパフォーマンスを向上し、グローバルスキーマビューを管理するための運用のオーバーヘッドを削減します。
* **イベント時間の並べ替え**：時系列スキーマの場合、取り込み時間ではなく、発生時間でイベントを並べ替えるには **タイムスタンプ識別子** を使用します。

## 必須フィールド

モデルベースのスキーマには、主要な動作と制約を制御するスキーマ定義のメタデータなど、特定の記述子が必要です。 スキーマ定義の一部として、次の記述子を追加します。

### プライマリキー記述子

プライマリキー記述子を使用して、各レコードが一意に識別可能であることを確認します。 サポートされている設定は次のとおりです。

* **単一フィールドプライマリキー**：各レコードに対して、一意の値を持つ 1 つのフィールドを使用します。
* **複合プライマリキー**：複数のフィールドを使用して一意の ID を形成します。 時系列スキーマの場合、複合キーには、タイムスタンプ記述子で識別されるタイムスタンプ フィールドが含まれている必要があります。

>[!NOTE]
>
>UI スキーマエディターでは、バージョン記述子とタイムスタンプ記述子は、それぞれ「[ !UICOTRNOL  バージョン識別子 ]」と「[ !UICOTRNOL  タイムスタンプ識別子 ]」として表示されます。

**例（単一フィールド）:**

```json
{
  "xdm:descriptor": "xdm:descriptorPrimaryKey",
  "xdm:sourceProperty": "customerId"
}
```

**例（時系列の場合は複合）**

```json
{
  "xdm:descriptor": "xdm:descriptorPrimaryKey",
  "xdm:sourceProperty": ["customerId", "eventTimestamp"]
}
```

### バージョン記述子（識別子）

正しいレコードの状態を維持し、最新の更新が適用されるように、バージョン記述子（識別子）を定義します。 複数のレコードが同じプライマリキーを共有する場合、バージョン値が最も高いレコードが最新のレコードと見なされます。

**例：**

```json
{
  "xdm:descriptor": "xdm:descriptorVersion",
  "xdm:sourceProperty": "lastModified"
}
```

### タイムスタンプ記述子（識別子）

時系列スキーマの場合は、タイムスタンプ記述子（識別子）を定義して、順序付けのイベント時間を設定します。

**例：**

```json
{
  "xdm:descriptor": "xdm:descriptorTimestamp",
  "xdm:sourceProperty": "eventTimestamp"
}
```

>[!NOTE]
>
>記述子はスキーマ定義メタデータの一部であり、データ行には保存されません。

スキーマエディターで記述子を作成する手順については、[ スキーマエディターでの記述子の作成 ](../tutorials/relationship-ui.md) を参照してください。 API ベースの作成については、[API を使用した記述子の作成 ](../tutorials/relationship-api.md) を参照してください。

## 関係のサポート {#relationship-support}

リレーショナルデータモデリングは、モデルベースのスキーマの主な用途です。 アプリケーションのユースケースでは、これらのスキーマを「リレーショナルスキーマ」と呼ぶ場合もあります。 関係記述子を使用すると、データ行に外部キーを埋め込まずにスキーマ間でデータセットをリンクすることで、これらの接続を有効にできます。 参照整合性が向上し、再利用可能なモデリング パターンが可能になり、アプリケーション間で接続されたクエリがサポートされます。

クエリ時に動的解決を行うために、関係記述子をスキーマレベルで作成します。 カーディナリティ値（1:1、多対 1）は、ガイダンスを提供しますが、取り込み時に制約が適用されず、接続されたデータセット間で柔軟なデータモデリングがサポートされます。

関係記述子を追加する前に、適切なタイプとターゲットを決定します。

* **1 対 1** - ソーススキーマの各レコードは、宛先スキーマの最大 1 つのレコードに対応します。
* **多対 1** - ソーススキーマ内の複数のレコードが、宛先スキーマ内の同じレコードを参照する場合があります。

>[!NOTE]
>
>2 つのモデルベースのスキーマ間、またはモデルベースのスキーマと標準スキーマ間の関係を定義できます。 アドホックスキーマへの関係はサポートされていません。

<!-- Q) 
Madeline commented: "model-based schema to standard might only be offered for b2b customers; that's how it will be on the UI" - is that still accurate? -->

**例：1 対 1 の関係**

```json
{
  "xdm:descriptor": "xdm:descriptorRelationship",
  "xdm:sourceProperty": "accountId",
  "xdm:destinationSchema": "https://ns.adobe.com/xdm/context/account",
  "xdm:destinationProperty": "accountId"
}
```

<!-- Q) 
Should these be `@type: "xdm:descriptorRelationship",` This could be a copy-pasting error? -->

**例：多対 1 の関係**

```json
{
  "xdm:descriptor": "xdm:descriptorRelationship",
  "xdm:sourceProperty": "customerId",
  "xdm:destinationSchema": "https://ns.adobe.com/xdm/context/customer",
  "xdm:destinationProperty": "customerId"
}
```

関係記述子のタイプと構文の一覧については、[descriptors API リファレンス ](../api/descriptors.md) を参照してください。これらの概念を実際に適用する方法については、チュートリアルに従って [API で関係を定義 ](../tutorials/relationship-api.md) または [UI で関係を作成 ](../tutorials/relationship-ui.md) してください。

>[!NOTE]
>
>関係はスキーマレベルで定義されるので、関連するデータセットをクエリで明示的に結合してください。 Data Distillerなどのツールを使用して、クエリ時にこれらの関係を解決します。

>[!IMPORTANT]
>
>関係のカーディナリティは情報提供であり、取り込み中には適用されません。 クエリまたは分析中に関係を解決する場合にのみ適用されます。 取り込み中にデータを検証する際に、カーディナリティの設定に依存しないようにします。 データを自分でチェックして消去し、定義した関係ルールが、データのクエリや分析を行う方法に一致していることを確認します。

>[!NOTE]
>
> モデルベースのスキーマは、標準スキーマにリンクできますが、アドホックスキーマにはリンクできません。

## データの削除とハイジーンに関する考慮事項 {#data-hygiene-support}

モデルベースのスキーマを使用すると、すべてのアプリケーションやユースケースに普遍的な影響を与える正確なレコードレベルの削除が可能になります。 プライマリキー、バージョン、タイムスタンプ記述子は、削除操作中にレコードを正確に識別するための基盤となります。

### ユニバーサル削除の影響

モデルベースのスキーマを使用するすべてのアプリケーションで次の点を考慮する必要があります。

* **参照整合性**：削除は、接続されたデータセット間の関連レコードに影響を与える可能性があります
* **コンプライアンス要件**：業界によっては、特定の削除行動と監査証跡が必要です
* **アプリケーションの動作**：ダウンストリームシステムで削除イベントを適切に処理する必要が生じる場合があります
* **データの一貫性**：関連するデータセットでは、削除操作中に一貫性を維持する必要があります
* **削除計画**：設計フェーズでは、接続されたすべてのデータセットとアプリケーションにわたるダウンストリームの影響を考慮します

実装ガイダンスについては、[ モデルベースのデータセットからのレコードの削除 ](../../hygiene/ui/record-delete.md#model-based-record-delete) を参照してください。

## 制限事項と考慮事項 {#limitations}

モデルベースのスキーマを使用する前に、次の制限事項を確認してください。

* モデルベースのスキーマは、和集合スキーマには使用されません。
* スキーマの進化は手動です。フィールドグループが変更されても、自動的には更新されません。

>[!IMPORTANT]
>
>スキーマを使用してデータセットが初期化されると、スキーマ進化が制限されます。 データを取り込むと、フィールドを削除または変更することはできないので、事前にフィールド名とタイプを慎重に計画します。

* 関係は 1 対 1 と多対 1 に制限されます。
* 使用できるかどうかは、ライセンスやイネーブルメント機能によって異なります。
* 時系列スキーマには、複合プライマリキーが必要です。

