---
keywords: Experience Platform；ホーム；人気のトピック；リレーショナルスキーマ；リレーショナルスキーマ；スキーマ；スキーマ；xdm；エクスペリエンスデータモデル；
solution: Experience Platform
title: リレーショナルスキーマ
description: 機能、必須フィールド、関係、制限など、Adobe Experience Platformのリレーショナルスキーマについて説明します。
badge: 限定提供
exl-id: 397e5937-b892-4fd3-b90e-29ed9229dc69
source-git-commit: 491588dab1388755176b5e00f9d8ae3e49b7f856
workflow-type: tm+mt
source-wordcount: '1280'
ht-degree: 0%

---

# リレーショナルスキーマ

>[!AVAILABILITY]
>
>Data Mirrorおよびリレーショナルスキーマは、Adobe Journey Optimizer **オーケストレートキャンペーン** のライセンスホルダーが利用できます。 ライセンスとイネーブルメント機能に応じて、Customer Journey Analytics ユーザー向けの **限定リリース** としても使用できます。 アクセスについては、Adobe担当者にお問い合わせください。

リレーショナルスキーマは、Adobe Experience Platform データレイク内の構造化データを表現するための、柔軟で制御されたモデリングパターンを提供します。 統合スキーマや完全なリレーショナルデータベースシステムに依存することなく、強制的なプライマリキー、スキーマレベルの関係、レコードの詳細な制御をサポートします。

>[!IMPORTANT]
>
>データ削除に関する考慮事項は、すべてのリレーショナルスキーマ実装に適用されます。 これらのスキーマを使用するアプリケーションでは、削除が関連データセット、コンプライアンス要件およびダウンストリームプロセスに与える影響を理解する必要があります。 実装する前に、削除シナリオを計画し、[&#x200B; データハイジーンのガイダンス &#x200B;](../../hygiene/ui/record-delete.md#relational-record-delete) を確認してください。

リレーショナルスキーマを使用して、次のことを行います。

* 単一フィールドまたは複合プライマリキーを適用してデータの整合性を確保する。
* 挿入、更新、削除のバージョン管理を使用して、正確な変更トラッキングを有効にします。
* 再利用可能なスキーマレベルの関係を定義して、実際のエンティティ接続をモデル化します。
* 複数のデータモデルをサポートすることで、アプリケーション間でスキーマ構造を複製するのを避けます。
* 結合スキーマの制約を回避して、オンボーディングを合理化し、スキーマの膨張を減らし、不要なスキーマ変更を回避します。

## リレーショナルスキーマと標準 XDM スキーマの違い

Experience Platformの標準 XDM スキーマは、レコード、時系列またはアドホックの 3 つのデータ動作のいずれかに従います。 定義と詳細については、[XDM データの動作 &#x200B;](https://experienceleague.adobe.com/ja/docs/experience-platform/xdm/home#data-behaviors) を参照してください。

従来のモデルでは、レコードと時系列スキーマは [&#x200B; 和集合スキーマ &#x200B;](../api/unions.md) に参加します（[&#x200B; 和集合スキーマ UI ガイド &#x200B;](../../profile/ui/union-schema.md) も参照）。 これらのスキーマは、共有 [&#x200B; フィールドグループ &#x200B;](./composition.md#field-group) が更新されると自動的に進化します。また、カスタムフィールドはテナント名前空間の下にネストする必要があります。 このモデルは強力ですが、オンボーディングの速度が低下したり、未使用のフィールドを含む過度に複雑なスキーマが生成されたり、追加のデータマッピングや変換が必要になったりする可能性があります。 これらの要因により、学習曲線が増加し、継続的なメンテナンス作業が増えます。

リレーショナルスキーマは、和集合スキーマの依存関係を削除します。これにより、共有フィールドグループからの自動更新が排除され、テナント名前空間の制限を伴わない直接フィールド定義が可能になります。 プライマリキー、関係、初期スキーマデザインを明示的に制御できるので、作成時にニーズに合わせてデータを簡単にモデル化できます。

## リレーショナルスキーマの機能

ガバナンス、整合性、相互運用性を維持しながら、データレイク内の構造化データをモデル化するには、次の機能を使用します。

* **スキーマ動作のサポート**：次を使用してを設定します。
   * **動作を記録**：顧客、アカウント、キャンペーンなど、エンティティの現在の状態をキャプチャします。
   * **時系列の動作**：イベントとイベントが発生する時間を取得します。シーケンスや時間の経過に伴う変化を追跡するのに役立ちます。
* **プライマリキーの適用**：各レコードを一意に識別し、取り込み中の重複を防ぐためのプライマリキーを定義します。
* **バージョン管理**: **バージョン識別子** （記述子）を使用して、レコードが順不同で到着した場合でも、更新が正しい順序で適用されるようにします。
* **関係マッピング**：リレーショナルスキーマ間、またはリレーショナルスキーマと標準スキーマの間に、1 対 1 または多対 1 の関係を作成します。 関係定義は、効率的な結合を可能にするために記述子として保存されます。
* **進化の簡略化**：リレーショナルスキーマは和集合ビューに関与せず、共有フィールドグループが変更されても更新されず、予期しないダウンストリームの変更を防ぎます。
* **柔軟なフィールド定義**：テナント ID の名前空間を設定せずに直接フィールドを追加します。 リレーショナルスキーマは、XDM フィールドグループをサポートしていません。
* **結合スキーマへの依存なし**：クエリのパフォーマンスを向上し、グローバルスキーマビューを管理するための運用のオーバーヘッドを削減します。
* **イベント時間の並べ替え**：時系列スキーマの場合、取り込み時間ではなく、発生時間でイベントを並べ替えるには **タイムスタンプ識別子** を使用します。

## 必須フィールド

リレーショナルスキーマには、特定の記述子（キーの動作と制約を制御するスキーマ定義のメタデータ）が必要です。 スキーマ定義の一部として、次の記述子を追加します。

### プライマリキー記述子

プライマリキー記述子を使用して、各レコードが一意に識別可能であることを確認します。 サポートされている設定は次のとおりです。

* **単一フィールドプライマリキー**：各レコードに対して、一意の値を持つ 1 つのフィールドを使用します。
* **複合プライマリキー**：複数のフィールドを使用して一意の ID を形成します。 時系列スキーマの場合、複合キーには、タイムスタンプ記述子で識別されるタイムスタンプ フィールドが含まれている必要があります。

>[!NOTE]
>
>UI スキーマエディターでは、バージョン記述子とタイムスタンプ記述子は、それぞれ「[!UICONTROL Version identifier]」と「[!UICONTROL Timestamp identifier]」として表示されます。

**例（単一フィールド）:**

```json
{
  "xdm:descriptor": "xdm:descriptorPrimaryKey",
  "xdm:sourceProperty": "customerId"
}
```

**例（時系列の場合は複合）**

```json
{
  "xdm:descriptor": "xdm:descriptorPrimaryKey",
  "xdm:sourceProperty": ["customerId", "eventTimestamp"]
}
```

### バージョン記述子（識別子）

正しいレコードの状態を維持し、最新の更新が適用されるように、バージョン記述子（識別子）を定義します。 複数のレコードが同じプライマリキーを共有する場合、バージョン値が最も高いレコードが最新のレコードと見なされます。

**例：**

```json
{
  "xdm:descriptor": "xdm:descriptorVersion",
  "xdm:sourceProperty": "lastModified"
}
```

### タイムスタンプ記述子（識別子）

時系列スキーマの場合は、タイムスタンプ記述子（識別子）を定義して、順序付けのイベント時間を設定します。

**例：**

```json
{
  "xdm:descriptor": "xdm:descriptorTimestamp",
  "xdm:sourceProperty": "eventTimestamp"
}
```

>[!NOTE]
>
>記述子はスキーマ定義メタデータの一部であり、データ行には保存されません。

スキーマエディターで記述子を作成する手順については、[&#x200B; スキーマエディターでの記述子の作成 &#x200B;](../tutorials/relationship-ui.md) を参照してください。 API ベースの作成については、[API を使用した記述子の作成 &#x200B;](../tutorials/relationship-api.md) を参照してください。

## 関係のサポート {#relationship-support}

リレーショナルデータモデリングは、リレーショナルスキーマの主な使用目的です。 アプリケーションのユースケースでは、これらのスキーマを「リレーショナルスキーマ」と呼ぶ場合もあります。 関係記述子を使用すると、データ行に外部キーを埋め込まずにスキーマ間でデータセットをリンクすることで、これらの接続を有効にできます。 参照整合性が向上し、再利用可能なモデリング パターンが可能になり、アプリケーション間で接続されたクエリがサポートされます。

クエリ時に動的解決を行うために、関係記述子をスキーマレベルで作成します。 カーディナリティ値（1:1、多対 1）は、ガイダンスを提供しますが、取り込み時に制約が適用されず、接続されたデータセット間で柔軟なデータモデリングがサポートされます。

関係記述子を追加する前に、適切なタイプとターゲットを決定します。

* **1 対 1** - ソーススキーマの各レコードは、宛先スキーマの最大 1 つのレコードに対応します。
* **多対 1** - ソーススキーマ内の複数のレコードが、宛先スキーマ内の同じレコードを参照する場合があります。

>[!NOTE]
>
>2 つのリレーショナルスキーマ間、またはリレーショナルスキーマと標準スキーマの間の関係を定義できます。 アドホックスキーマへの関係はサポートされていません。

**例：1 対 1 の関係**

```json
{
  "xdm:descriptor": "xdm:descriptorRelationship",
  "xdm:sourceProperty": "accountId",
  "xdm:destinationSchema": "https://ns.adobe.com/xdm/context/account",
  "xdm:destinationProperty": "accountId"
}
```

**例：多対 1 の関係**

```json
{
  "xdm:descriptor": "xdm:descriptorRelationship",
  "xdm:sourceProperty": "customerId",
  "xdm:destinationSchema": "https://ns.adobe.com/xdm/context/customer",
  "xdm:destinationProperty": "customerId"
}
```

関係記述子のタイプと構文の一覧については、[descriptors API リファレンス &#x200B;](../api/descriptors.md) を参照してください。これらの概念を実際に適用する方法については、チュートリアルに従って [API で関係を定義 &#x200B;](../tutorials/relationship-api.md) または [UI で関係を作成 &#x200B;](../tutorials/relationship-ui.md) してください。

>[!NOTE]
>
>関係はスキーマレベルで定義されるので、関連するデータセットをクエリで明示的に結合してください。 Data Distillerなどのツールを使用して、クエリ時にこれらの関係を解決します。

>[!IMPORTANT]
>
>関係のカーディナリティは情報提供であり、取り込み中には適用されません。 クエリまたは分析中に関係を解決する場合にのみ適用されます。 取り込み中にデータを検証する際に、カーディナリティの設定に依存しないようにします。 データを自分でチェックして消去し、定義した関係ルールが、データのクエリや分析を行う方法に一致していることを確認します。

>[!NOTE]
>
>リレーショナルスキーマは標準スキーマにリンクできますが、アドホックスキーマにリンクすることはできません。

## データの削除とハイジーンに関する考慮事項 {#data-hygiene-support}

リレーショナルスキーマを使用すると、すべてのアプリケーションとユースケースに普遍的な影響を与える正確なレコードレベルの削除が可能になります。 プライマリキー、バージョン、タイムスタンプ記述子は、削除操作中にレコードを正確に識別するための基盤となります。

### ユニバーサル削除の影響

リレーショナルスキーマを使用するすべてのアプリケーションでは、次の点を考慮する必要があります。

* **参照整合性**：削除は、接続されたデータセット間の関連レコードに影響を与える可能性があります
* **コンプライアンス要件**：業界によっては、特定の削除行動と監査証跡が必要です
* **アプリケーションの動作**：ダウンストリームシステムで削除イベントを適切に処理する必要が生じる場合があります
* **データの一貫性**：関連するデータセットでは、削除操作中に一貫性を維持する必要があります
* **削除計画**：設計フェーズでは、接続されたすべてのデータセットとアプリケーションにわたるダウンストリームの影響を考慮します

実装ガイダンスについては、[&#x200B; リレーショナルスキーマに基づくデータセットからのレコードの削除 &#x200B;](../../hygiene/ui/record-delete.md#relational-record-delete) を参照してください。

## 制限と考慮事項 {#limitations}

リレーショナルスキーマを使用する前に、次の制限事項を確認してください。

* リレーショナルスキーマは結合スキーマには使用されません。
* スキーマの進化は手動です。フィールドグループが変更されても、自動的には更新されません。

>[!IMPORTANT]
>
>スキーマを使用してデータセットが初期化されると、スキーマ進化が制限されます。 データを取り込むと、フィールドを削除または変更することはできないので、事前にフィールド名とタイプを慎重に計画します。

* 関係は 1 対 1 と多対 1 に制限されます。
* 使用できるかどうかは、ライセンスやイネーブルメント機能によって異なります。
* 時系列スキーマには、複合プライマリキーが必要です。
